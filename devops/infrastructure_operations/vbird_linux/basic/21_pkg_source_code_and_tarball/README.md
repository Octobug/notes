# 第二十一章 软件安装：源代码与 Tarball

> <https://linux.vbird.org/linux_basic/centos7/0520source_code_and_tarball.php>

## 目录

- [第二十一章 软件安装：源代码与 Tarball](#第二十一章-软件安装源代码与-tarball)
  - [目录](#目录)
  - [21.1 开源软件的安装与升级简介](#211-开源软件的安装与升级简介)
    - [21.1.1 什么是开源、编译器与可执行文件](#2111-什么是开源编译器与可执行文件)
    - [21.1.2 什么是函数库](#2112-什么是函数库)
    - [21.1.3 什么是 make 与 configure](#2113-什么是-make-与-configure)
    - [21.1.4 什么是 Tarball 软件](#2114-什么是-tarball-软件)
    - [21.1.5 如何安装与升级软件](#2115-如何安装与升级软件)
  - [21.2 使用传统程序语言进行编译的简单范例](#212-使用传统程序语言进行编译的简单范例)
    - [21.2.1 单一程序：打印 Hello World](#2121-单一程序打印-hello-world)
    - [21.2.2 主、副程序链接：副程序的编译](#2122-主副程序链接副程序的编译)
    - [21.2.3 调用外部函数库：加入链接的函数库](#2123-调用外部函数库加入链接的函数库)
    - [21.2.4 gcc 的简易用法（编译、参数与链接）](#2124-gcc-的简易用法编译参数与链接)
  - [21.3 用 make 进行宏编译](#213-用-make-进行宏编译)
    - [21.3.1 为什么要用 make](#2131-为什么要用-make)
    - [21.3.2 makefile 的基本语法与变量](#2132-makefile-的基本语法与变量)
  - [21.4 Tarball 的管理与建议](#214-tarball-的管理与建议)
    - [21.4.1 使用源代码管理软件所需要的基础软件](#2141-使用源代码管理软件所需要的基础软件)
    - [21.4.2 Tarball 安装的基本步骤](#2142-tarball-安装的基本步骤)
    - [21.4.3 一般 Tarball 软件安装的建议事项（如何移除？升级）](#2143-一般-tarball-软件安装的建议事项如何移除升级)
    - [21.4.4 一个简单的范例：ntp 的安装](#2144-一个简单的范例ntp-的安装)
    - [21.4.5 利用 patch 更新源代码](#2145-利用-patch-更新源代码)
  - [21.5 函数库管理](#215-函数库管理)
    - [21.5.1 动态与静态函数库](#2151-动态与静态函数库)
    - [21.5.2 ldconfig 与 /etc/ld.so.conf](#2152-ldconfig-与-etcldsoconf)
    - [21.5.3 程序的动态函数库解析：ldd](#2153-程序的动态函数库解析ldd)
  - [21.6 校验软件正确性](#216-校验软件正确性)
    - [21.6.1 md5sum/sha1sum/sha256sum](#2161-md5sumsha1sumsha256sum)
  - [21.7 重点回顾](#217-重点回顾)
  - [21.8 本章习题](#218-本章习题)
  - [21.9 参考资料与延伸阅读](#219-参考资料与延伸阅读)

最原始的软件管理方式：使用 Tarball 来安装与升级管理软件。

## 21.1 开源软件的安装与升级简介

### 21.1.1 什么是开源、编译器与可执行文件

### 21.1.2 什么是函数库

### 21.1.3 什么是 make 与 configure

- make: 使用 Makefile 按一定规则编译源代码
- configure: 检测系统环境、软件依赖等，通过之后创建 Makefile 文件
  - 是否有合适的编译器
  - 是否存在所需函数库或其他软件依赖
  - 操作系统平台、Linux 内核是否适合
  - 内核的头文件是否满足

### 21.1.4 什么是 Tarball 软件

tarball: 用 tar 打包 + 其他工具压缩。这类软件包通常包含

- 源代码
- configure
- 简易说明文档 INSTALL 或 README

### 21.1.5 如何安装与升级软件

- 以源代码安装与升级
- 以编译好的 binary program 来安装与升级

Tarball 安装流程：

1. 下载 tarball
2. 解压
3. 使用编译器如 gcc 进行编译
4. 链接目标文件、函数库等，形成 binary file
5. 安装 binary file 及配置文件到具体位置

## 21.2 使用传统程序语言进行编译的简单范例

### 21.2.1 单一程序：打印 Hello World

`gcc *.c` 等同于

- `gcc -c hello.c`
- `gcc -o hello hello.o`

### 21.2.2 主、副程序链接：副程序的编译

- `gcc -c thanks.c thanks2.c`
- `gcc -o thanks thanks.o thanks2.o`

### 21.2.3 调用外部函数库：加入链接的函数库

gcc 会默认寻找系统中存放库文件的路径，包括：`/lib`, `/lib64`, `/usr/include`，
也可以使用 `gcc sin.c -lm -L/lib -L/lib64` 指定函数库位置。

- `-l`: 加入函数库
- `-m`: `lib<m>.so`

### 21.2.4 gcc 的简易用法（编译、参数与链接）

- `-c`
- `-O *c -c`
- `-Wall`

## 21.3 用 make 进行宏编译

### 21.3.1 为什么要用 make

- 简化编译时需要下达的命令
- 编译完成后如果修改了代码，make 只会编译修改部分的文件，其他 object file 不会重新编译
- 可以按照相依性来更新可执行文件

### 21.3.2 makefile 的基本语法与变量

```make
target: object_file_1 object_file_2
<tab> gcc -o bin_name object_file_1 object_file_2
```

- `#` 为注释
- `<tab>` 必须是包含命令所在行的第一个字符
- `target` 与 object file 之间用 `:` 隔开

make 变量语法：

- 变量与值使用 `=`，两边可以有空格
- 变量左边不可以有 `<tab>`
- 习惯上变量使用全大写字母
- 引用变量时使用 ${} 或 $()
- 可以引用 shell 的环境变量与普通变量
    1. make 命令行后面加上的环境变量优先
    2. makefile 里定义的环境变量第二
    3. shell 原本具有的环境变量第三
- $@: 代表目前的 target

## 21.4 Tarball 的管理与建议

### 21.4.1 使用源代码管理软件所需要的基础软件

- gcc 或 cc 等 C 语言编译器
- make 与 autoconfig
- Kernel 提供的 Library 与相关的头文件

### 21.4.2 Tarball 安装的基本步骤

1. 获取原始文件：下载 tarball 文件并解压到 `/usr/local/src` 目录
2. 获取具体步骤：查阅解压出来的 INSTALL/README 文件
3. 依赖软件安装：根据 INSTALL/README 的内容查看并安装好依赖软件
4. 创建 makefile: 运行 ./configure 或 ./config
5. 编译：make
6. 安装：make install
7. 手动将 man page 路径加入到 `/etc/man_db.conf`

### 21.4.3 一般 Tarball 软件安装的建议事项（如何移除？升级）

默认安装在 `/usr/local/` 底下，并按软件使用单一目录，如：

- app/etc
- app/bin
- app/lib
- app/man

建议：

1. 将 tarball 的原始数据解压到 `/usr/local/src` 中
2. 安装时安装到 `/usr/local`
3. 为方便移除，每个软件有自己的单独目录
4. 将新安装的软件加入 /etc/man_db.conf

### 21.4.4 一个简单的范例：ntp 的安装

### 21.4.5 利用 patch 更新源代码

1. patch
2. make clean main
3. make install

## 21.5 函数库管理

### 21.5.1 动态与静态函数库

- 动态函数库
  - 扩展名：`.so`
  - 编译行为：不整合进可执行文件里，可执行文件只会有 pointer 记录 .so 文件的位置。
    在执行时需要使用到函数库时才会去读取调用。
  - 独立执行的状态：这类函数库编译出来的可执行文件不能被独立执行，而要依赖库文件。
    且库文件位置不能随便移动。
  - 升级难易度：函数库升级只需要重新编译函数库。
- 静态函数库
  - 扩展名：`.a`
  - 编译行为：编译时会直接整合进可执行程序中，因此整个文件体积会比较大。
  - 独立执行的状态：可执行文件可以独立执行，不需要依赖外部库文件。
  - 升级难易度：函数库升级时整个文件都要重新编译

Linux distribution 倾向于使用动态函数库：`/lib`, `/lib64`, `/lib/moduels`

### 21.5.2 ldconfig 与 /etc/ld.so.conf

将函数库预先读取到内存中使用可加快程序运行速度，此时就需要 `ldconfig` 与
`/etc/ld.so.conf`；

### 21.5.3 程序的动态函数库解析：ldd

- `ldd [-drv] FILENAME`
  - `-d`: 列出数据有遗失的 link point
  - `-r`: 列出与 ELF 有关的错误内容
  - `-v`: 列出所有内容信息

## 21.6 校验软件正确性

### 21.6.1 md5sum/sha1sum/sha256sum

## 21.7 重点回顾

- 原始碼其實大多是純文字檔，需要透過編譯器的編譯動作後，才能夠製作出 Linux
  系統能夠認識的可執行的 binary file ；
- 開放原始碼可以加速軟體的更新速度，讓軟體效能更快、漏洞修補更即時；
- 在 Linux 系統當中，最標準的 C 語言編譯器為 gcc ；
- 在編譯的過程當中，可以藉由其他軟體提供的函式庫來使用該軟體的相關機制與功能；
- 為了簡化編譯過程當中的複雜的指令輸入，可以藉由 make 與 makefile 規則定義，
  來簡化程式的更新、編譯與連結等動作；
- Tarball 為使用 tar 與 gzip/bzip2/xz 壓縮功能所打包與壓縮的，具有原始碼的檔案；
- 一般而言，要使用 Tarball 管理 Linux 系統上的軟體，最好需要 gcc, make, autoconfig,
  kernel source, kernel header 等前驅軟體才行，所以在安裝 Linux 之初，
  最好就能夠選擇 Software development 以及 kernel development 之類的群組；
- 函式庫有動態函式庫與靜態函式庫，動態函式庫在升級上具有較佳的優勢。動態函式庫的副檔名為
  `*.so` 而靜態則是 `*.a`；
- patch 的主要功能在更新原始碼，所以更新原始碼之後，還需要進行重新編譯的動作才行；
- 可以利用 `ldconfig` 與 `/etc/ld.so.conf` `/etc/ld.so.conf.d/*.conf`
  來製作動態函式庫的連結與快取！
- 透過 MD5/SHA1/SHA256 的編碼可以判斷下載的檔案是否為原本廠商所釋出的檔案。

## 21.8 本章习题

## 21.9 参考资料与延伸阅读

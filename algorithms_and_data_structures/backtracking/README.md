# Back Tracking

- [Back Tracking](#back-tracking)
  - [理论基础](#理论基础)
  - [回溯法的效率](#回溯法的效率)
  - [回溯法解决的问题](#回溯法解决的问题)
  - [如何理解回溯法](#如何理解回溯法)
  - [回溯法模板（三步曲）](#回溯法模板三步曲)
    - [一、返回值以及参数](#一返回值以及参数)
    - [二、终止条件](#二终止条件)
    - [三、的遍历过程](#三的遍历过程)
  - [性能分析](#性能分析)
    - [子集问题](#子集问题)
    - [排列问题](#排列问题)
    - [组合问题](#组合问题)
  - [References](#references)

## 理论基础

- **回溯法**也可以叫做**回溯搜索法**，它是一种搜索的方式。
- 回溯是递归的副产品，只要有递归就会有回溯。

## 回溯法的效率

虽然回溯法不好理解，但是回溯法并不是什么高效的算法。

因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝操作，但也改不了回溯法就是穷举的本质。

既然回溯法并不高效为什么还要用它呢？因为没得选，有些问题只能暴力搜出来，最多再剪枝一下，并没有更高效的解法。

## 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- **组合问题**：N 个数里面按一定规则找出 k 个数的集合
- **切割问题**：一个字符串按一定规则有几种切割方式
- **子集问题**：一个 N 个数的集合里有多少符合条件的子集
- **排列问题**：N 个数按一定规则全排列，有几种排列方式
- **棋盘问题**：N 皇后，解数独等等

## 如何理解回溯法

所有回溯法解决的问题都可以抽象为树形结构。

因为回溯法解决的都是在集合中递归查找子集，**集合的大小构成了树的宽度，递归的深度构成树的深度。

递归就要有终止条件，所以必然是一棵高度有限的树（N 叉树）。

## 回溯法模板（三步曲）

### 一、返回值以及参数

- 回溯算法中函数返回值一般为 `void`
- 因为回溯算法需要的参数不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

回溯函数伪代码如下：

```cpp
void backtracking(参数)
```

### 二、终止条件

一般来说搜到叶子节点了，也就找到满足条件的一条答案，把这个答案存放起来，并结束本层递归。

所以回溯函数终止条件伪代码如下：

```cpp
if (终止条件) {
    存放结果;
    return;
}
```

### 三、的遍历过程

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

回溯函数遍历过程伪代码如下：

```cpp
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

`for` 循环就是遍历集合区间，可以理解一个结点有多少个孩子，这个 `for` 循环就执行多少次。
`for` 循环可以理解是横向遍历，`backtracking` 就是纵向遍历，这样就把这棵树遍历完了，一般来说，搜索叶子节点就是找到其中一个结果。

分析完整个过程，回溯算法模板框架如下：

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 性能分析

### 子集问题

- **时间复杂度**：$O(n × 2^n)$，每一个元素的状态为**取**与**不取**，所以时间复杂度为
  $O(2^n)$，构造每一组子集都需要填进数组，又有需要 $O(n)$，最终时间复杂度：$O(n × 2^n)$。
- **空间复杂度**：$O(n)$，递归深度为 `n`，所以系统栈所用空间为 $O(n)$，每一层递归所用的空间都是常数级别。
  代码里的 `result` 和 `path` 都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为 $O(n)$。

### 排列问题

- **时间复杂度**：$O(n!)$，这个可以从排列的树形图中看出，第一层节点为 `n`，第二层每一个分支都延伸了 `n-1` 个分支，再往下是 `n-2`
  个分支，所以一直到叶子节点一共就是  `n * n-1 * n-2 * ... * 1 = n!`。
  每个叶子结点都会有一个构造全排列填进数组的操作，该操作的复杂度为 $O(n)$。
  所以，最终时间复杂度为：`n * n!`，简化为 $O(n!)$。
- **空间复杂度**：$O(n)$，和子集问题同理。

### 组合问题

- **时间复杂度**：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- **空间复杂度**：$O(n)$，和子集问题同理。

一般说道回溯算法的复杂度，都说是指数级别的时间复杂度。

## References

- 回溯算法
  - [x] [回溯算法理论基础](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)
  - [x] [组合问题](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)
  - [x] [组合（优化）](https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html)
  - [x] [组合总和III](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)
  - [x] [电话号码的字母组合](https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)
  - [x] [回溯周末总结](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201030%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
  - [x] [组合总和](https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)
  - [x] [组合总和II](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)
  - [x] [分割回文串](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)
  - [x] [复原IP地址](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)
  - [x] [子集问题](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)
  - [x] [回溯周末总结](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201107%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
  - [x] [子集II](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)
  - [x] [递增子序列](https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html)
  - [x] [全排列](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)
  - [x] [全排列II](https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html)
  - [x] [回溯周末总结](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201112%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
  - [x] [回溯算法去重问题的另一种写法](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.html)
  - [x] [重新安排行程](https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html)
  - [ ] [N皇后](https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html)
  - [ ] 解数独
  - [ ] 回溯法总结篇

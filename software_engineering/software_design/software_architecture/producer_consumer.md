# 生产者/消费者模式

- [生产者/消费者模式](#生产者消费者模式)
  - [简介](#简介)
    - [优点](#优点)
  - [数据单元的确定](#数据单元的确定)
    - [数据单元的特性](#数据单元的特性)
  - [队列缓冲区](#队列缓冲区)
    - [线程方式](#线程方式)
      - [内存分配的性能](#内存分配的性能)
      - [同步和互斥的性能](#同步和互斥的性能)
      - [队列缓冲区的适用场景](#队列缓冲区的适用场景)
    - [进程方式](#进程方式)
      - [匿名管道](#匿名管道)
      - [TCP 方式 (SOCKET)](#tcp-方式-socket)

## 简介

在这个模式中，除了生产者和消费者，还有数据缓冲区。

### 优点

- 解耦：生产者代码若直接调用消费者代码，会使它们之间产生依赖；
- 支持并发：如果生产者代码直接调用消费者代码，函数调用是同步的（或者说阻塞的）；
- 支持忙闲不均：缓冲区使生产者不同时间下的生产速率平均化，缓解高峰压力。

## 数据单元的确定

数据单元即是生产者每次放到缓冲区内、消费者从缓冲区内取出的一份数据。

### 数据单元的特性

- 关联业务对象
- 完整性
- 独立性
- 颗粒度：出于性能因素的考虑，可以统一将多个业务数据单元打包成一个大的数据单元

## 队列缓冲区

### 线程方式

#### 内存分配的性能

在线程方式下，生产者和消费者各自是一个线程。
生产者把数据写入队列头 (`push`)，消费者从队列尾部读出数据 (pop)。
当队列为空，消费者就休息 (可以是 `sleep`)；当队列满生产者就休息。

这种模式主要的问题是内存分配的性能开销。
常见的队列实现在每次 `push` 时可能涉及堆内存的分配；在每次 `pop` 时可能涉及堆内存的释放。

假如生产者和消费者都很活跃，频繁地 `push` 和 `pop`，那么内存分配的开销将很可观。

#### 同步和互斥的性能

由于两个线程共用一个队列，会涉及线程间诸如同步、互斥、死锁等问题。
信号量、互斥量之类的使用也有不小的开销（某些情况下，也可能导致用户态/内核态的切换）。

#### 队列缓冲区的适用场景

大部分编程语言都内置了队列，有些甚至提供了线程安全的队列。
假如数据量不是很大，采用队列缓冲区的好处是比较明显的：

- 逻辑清晰
- 代码简单
- 维护方便

### 进程方式

跨进程的生产者/消费者模式非常依赖具体的进程间通讯 (IPC) 方式。

#### 匿名管道

管道是最像队列的 IPC 类型。生产者进程在写端放入数据；消费者进程在读端取出数据。
区别在于使用管道无需操心线程安全、内存分配等琐事（由操作系统自动管理）。

管道分“命名管道”和“匿名管道”，命名管道在不同的操作系统下差异较大，对于有些编程语言命名管道甚至是无法使用的。

匿名管道在不同平台上的接口也有差异，但是可以使用 `stdin` 和 `stdout` 来进行数据的流入流出。
然后利用 shell 的管道符把生产者进程和消费者进程关联起来。
实际上，很多操作系统自带的命令（`more`, `grep` 等）都充分利用了这个特性来实现数据传输。

好处：

1. 大多数操作系统支持在 shell 方式下使用管道符，有利于跨平台。
2. 大部分编程语言都能够操作 `stdio`，有利于跨编程语言实现。
3. 管道方式避开了线程安全方面的问题，有利于降低开发调试成本。

缺点：

1. 生产者进程和消费者进程必须在同一台主机，无法跨机器通讯。
2. 难以扩展到一对多或者多对一。
3. 由于管道是 shell 创建的，对于两边的进程不可见，程序不便于对管道进行操纵。
4. 只能单向传数据。
5. 对 `stdio` 进行读写操作是阻塞的，比如消费者进程的读操作可能会一直等待直到管道中有数据。
6. `stdio` 内部带有自己的缓冲区，数据传递的及时性不佳。

#### TCP 方式 (SOCKET)

基于 TCP 方式的 SOCKET 也是类似于队列的 IPC 方式。
它同样保证数据的顺序到达，有缓冲机制，而且也是跨平台和跨语言的。

SOCKET 相比 shell 管道符的优点：

1. 可以跨机器实现分布式。
2. 便于扩展为多对一或者一对多。
3. 可以设置阻塞和非阻塞方法，用起来比较灵活。
4. 支持双向通讯，有利于消费者反馈信息。

缺点：在编程上会更复杂一些。

目前已有很多 SOCKET 通讯库和框架（比如 C++ 的 ACE 库、Python 的 Twisted）。

虽然 TCP 在很多方面比 UDP 可靠，但鉴于网络通讯的不可预料性，最好在程序上也做一些健壮性设计。
比如在生产者进程和消费者进程内部各自再引入基于线程的“生产者/消费者模式”。

关键点在于把代码分为两部分：

- 生产线程/消费线程属于业务代码（但和通讯无关）
- 发送线程/接收线程属于通讯代码（但和业务无关）

好处：

1. 能应对暂时性的网络故障。
2. 网络故障的应对处理方式只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。
3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。
4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）
5. 业务逻辑的变化不影响发送线程和接收线程。

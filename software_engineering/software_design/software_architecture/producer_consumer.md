# 生产者/消费者模式

- [生产者/消费者模式](#生产者消费者模式)
  - [简介](#简介)
    - [优点](#优点)
  - [数据单元的确定](#数据单元的确定)
    - [数据单元的特性](#数据单元的特性)
  - [队列缓冲区](#队列缓冲区)
    - [线程方式](#线程方式)
      - [内存分配的性能](#内存分配的性能)
      - [同步和互斥的性能](#同步和互斥的性能)
      - [队列缓冲区的适用场景](#队列缓冲区的适用场景)
    - [进程方式](#进程方式)
      - [匿名管道](#匿名管道)
      - [TCP 方式 (SOCKET)](#tcp-方式-socket)
  - [环形缓冲区](#环形缓冲区)
    - [环形缓冲区 vs 队列缓冲区](#环形缓冲区-vs-队列缓冲区)
      - [外部接口](#外部接口)
      - [内部结构](#内部结构)
    - [环形缓冲区的实现](#环形缓冲区的实现)
      - [数组方式 vs 链表方式](#数组方式-vs-链表方式)
      - [读写操作](#读写操作)
      - [判断“空”和“满”](#判断空和满)
      - [元素的存储](#元素的存储)
    - [应用场景](#应用场景)
      - [并发线程](#并发线程)
      - [并发进程](#并发进程)

## 简介

在这个模式中，除了生产者和消费者，还有数据缓冲区。

### 优点

- 解耦：生产者代码若直接调用消费者代码，会使它们之间产生依赖；
- 支持并发：如果生产者代码直接调用消费者代码，函数调用是同步的（或者说阻塞的）；
- 支持忙闲不均：缓冲区使生产者不同时间下的生产速率平均化，缓解高峰压力。

## 数据单元的确定

数据单元即是生产者每次放到缓冲区内、消费者从缓冲区内取出的一份数据。

### 数据单元的特性

- 关联业务对象
- 完整性
- 独立性
- 颗粒度：出于性能因素的考虑，可以统一将多个业务数据单元打包成一个大的数据单元

## 队列缓冲区

### 线程方式

#### 内存分配的性能

在线程方式下，生产者和消费者各自是一个线程。
生产者把数据写入队列头 (`push`)，消费者从队列尾部读出数据 (pop)。
当队列为空，消费者就休息 (可以是 `sleep`)；当队列满生产者就休息。

这种模式主要的问题是内存分配的性能开销。
常见的队列实现在每次 `push` 时可能涉及堆内存的分配；在每次 `pop` 时可能涉及堆内存的释放。

假如生产者和消费者都很活跃，频繁地 `push` 和 `pop`，那么内存分配的开销将很可观。

#### 同步和互斥的性能

由于两个线程共用一个队列，会涉及线程间诸如同步、互斥、死锁等问题。
信号量、互斥量之类的使用也有不小的开销（某些情况下，也可能导致用户态/内核态的切换）。

#### 队列缓冲区的适用场景

大部分编程语言都内置了队列，有些甚至提供了线程安全的队列。
假如数据量不是很大，采用队列缓冲区的好处是比较明显的：

- 逻辑清晰
- 代码简单
- 维护方便

### 进程方式

跨进程的生产者/消费者模式非常依赖具体的进程间通讯 (IPC) 方式。

#### 匿名管道

管道是最像队列的 IPC 类型。生产者进程在写端放入数据；消费者进程在读端取出数据。
区别在于使用管道无需操心线程安全、内存分配等琐事（由操作系统自动管理）。

管道分“命名管道”和“匿名管道”，命名管道在不同的操作系统下差异较大，对于有些编程语言命名管道甚至是无法使用的。

匿名管道在不同平台上的接口也有差异，但是可以使用 `stdin` 和 `stdout` 来进行数据的流入流出。
然后利用 shell 的管道符把生产者进程和消费者进程关联起来。
实际上，很多操作系统自带的命令（`more`, `grep` 等）都充分利用了这个特性来实现数据传输。

好处：

1. 大多数操作系统支持在 shell 方式下使用管道符，有利于跨平台。
2. 大部分编程语言都能够操作 `stdio`，有利于跨编程语言实现。
3. 管道方式避开了线程安全方面的问题，有利于降低开发调试成本。

缺点：

1. 生产者进程和消费者进程必须在同一台主机，无法跨机器通讯。
2. 难以扩展到一对多或者多对一。
3. 由于管道是 shell 创建的，对于两边的进程不可见，程序不便于对管道进行操纵。
4. 只能单向传数据。
5. 对 `stdio` 进行读写操作是阻塞的，比如消费者进程的读操作可能会一直等待直到管道中有数据。
6. `stdio` 内部带有自己的缓冲区，数据传递的及时性不佳。

#### TCP 方式 (SOCKET)

基于 TCP 方式的 SOCKET 也是类似于队列的 IPC 方式。
它同样保证数据的顺序到达，有缓冲机制，而且也是跨平台和跨语言的。

SOCKET 相比 shell 管道符的优点：

1. 可以跨机器实现分布式。
2. 便于扩展为多对一或者一对多。
3. 可以设置阻塞和非阻塞方法，用起来比较灵活。
4. 支持双向通讯，有利于消费者反馈信息。

缺点：在编程上会更复杂一些。

目前已有很多 SOCKET 通讯库和框架（比如 C++ 的 ACE 库、Python 的 Twisted）。

虽然 TCP 在很多方面比 UDP 可靠，但鉴于网络通讯的不可预料性，最好在程序上也做一些健壮性设计。
比如在生产者进程和消费者进程内部各自再引入基于线程的“生产者/消费者模式”。

关键点在于把代码分为两部分：

- 生产线程/消费线程属于业务代码（但和通讯无关）
- 发送线程/接收线程属于通讯代码（但和业务无关）

好处：

1. 能应对暂时性的网络故障。
2. 网络故障的应对处理方式只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。
3. 具体的 SOCKET 方式（阻塞和非阻塞）只影响发送和接收线程，不影响生产线程和消费线程（业务逻辑部分）。
4. 不依赖 TCP 自身的发送缓冲区和接收缓冲区。（默认的 TCP 缓冲区的大小可能无法满足实际要求）
5. 业务逻辑的变化不影响发送线程和接收线程。

## 环形缓冲区

当存储空间的分配和释放非常频繁并且确实产生明显影响时，应该考虑使用环形缓冲区。

### 环形缓冲区 vs 队列缓冲区

#### 外部接口

- 普通队列有一个写入端和一个读出端。队列为空时，读出端无法读取数据；队列满时，写入端无法写入数据。
- 对于使用者，环形缓冲区和队列缓冲区是一样的。它也有一个写入端和一个读出端，也有缓冲区“满”和“空”的状态。

#### 内部结构

在环形缓冲区中，当写入端 W 追上读出端 R 的时，就是缓冲区满。

环形缓冲区所有的 `push`/`pop` 操作都是在固定的存储空间内进行。
而队列缓冲区在 `push` 时，可能需要分配存储空间用于存储新元素；
在 `pop` 时，可能会释放废弃元素的存储空间。

环形缓冲区少了对缓冲区存储空间的分配、释放。这是环形缓冲区的一个主要优势。

### 环形缓冲区的实现

#### 数组方式 vs 链表方式

环形缓冲区的内部实现，可基于数组（泛指连续存储空间）实现，也可基于链表实现。

数组在物理存储上是一维的连续线性结构，可以在初始化时，把存储空间一次性分配好，这是其优点。
使用数组模拟环，必须在逻辑上把数组的头和尾相连。在顺序遍历数组时，对尾部元素要作特殊处理。
访问尾部元素下一个元素时，要重新回到头部元素。

使用链表的方式和数组相反：链表省去了头尾相连的特殊处理。但是链表在初始化时比较繁琐，而且在有些场合（比如跨进程的 IPC）不太方便使用。

#### 读写操作

环形缓冲区要维护两个索引，分别对应写入端 W 和读取端 R。
写入时，先确保环没满，然后把数据复制到 W 的位置，最后 W 指向下一个位置；
读取时，先确保环没空，然后返回 R 对应的元素，最后 R 指向下一个位置。

#### 判断“空”和“满”

空环和满环的时候，R 和 W 都指向同一个位置。这样就无法判断到底是“空”还是“满”。有两种方法可以解决该问题：

- 始终保持一个元素不用：当 W 比 R 跑得快，追到距离 R 还有一个元素间隔的时候，就认为环已经满。当环内元素存储空间较大时，这种办法比较浪费空间。
- 维护额外变量：用一个整数记录当前环中已经保存的元素个数。当 R 和 W 重叠的时候，通过该变量就可以判断是“空”还是“满”。

#### 元素的存储

环形缓冲区本身就是为了降低存储空间分配的开销，因此缓冲区中元素的类型要选好。
尽量存储值类型数据，而不要存储指针（引用）类型的数据。
因为指针类型的数据会引起存储空间（比如堆内存）的分配和释放，使得环形缓冲区的效果大打折扣。

### 应用场景

#### 并发线程

线程中的环形缓冲区也要考虑线程安全（除非使用的环形缓冲区的库已经实现了线程安全）。

- C++: `circular_buffer` 模板 (boost)
- C: `circbuf`
- C#: `CodeProject`

#### 并发进程

适合进行环形缓冲的 IPC 类型，常见的有“共享内存和文件”。
在这两种方式上进行环形缓冲，通常都采用数组的方式实现。

共享内存方式的性能好，适用于数据量很大的场景。但是有些语言（比如 Java）不支持共享内存。因此，该方式在多语言协同开发中方有一定局限性。

文件方式在编程语言方面支持更好，但它可能受限于磁盘读写性能。所以文件方式不适合用于快速数据传输；
不过对于某些“数据单元”很大的场景，文件方式是值得考虑的。

对于进程间的环形缓冲区，同样要考虑好进程间的同步、互斥等问题。

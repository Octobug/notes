# Life Cycle

- [Life Cycle](#life-cycle)
  - [类对象](#类对象)
    - [确保析构执行的重要性](#确保析构执行的重要性)
    - [类对象的析构（销毁）](#类对象的析构销毁)
      - [不同死法对于对象是否能析构的影响](#不同死法对于对象是否能析构的影响)
      - [析构的顺序](#析构的顺序)
  - [Win32 线程](#win32-线程)
    - [OS API vs CRT API](#os-api-vs-crt-api)
    - [线程终结的三种方法](#线程终结的三种方法)
      - [自然死亡](#自然死亡)
      - [自杀](#自杀)
      - [他杀](#他杀)
      - [类对象的析构](#类对象的析构)
      - [主线程的结束](#主线程的结束)
  - [PISIX 线程 (`pthread`)](#pisix-线程-pthread)
    - [pthread 的他杀](#pthread-的他杀)
    - [pthread 类对象的析构](#pthread-类对象的析构)
    - [主线程之死](#主线程之死)

## 类对象

### 确保析构执行的重要性

内存泄漏在进程退出后，内存可以被操作系统回收，但是其他资源却不一定，比程序临时创建的一些文件。

C++ 中常用 Guard 模式来做进程资源的回收：

```cpp
class CTempDirGuard
{
public:
    CTempDirGuard(const string& sFolderName)
    {
        // 创建某临时目录
    }

    virtual ~CTempDirGuard()
    {
        // 把该临时目录整个儿删除
    }
};

void Foo()
{
    CTempDirGuard guard(xxx);  // 声明guard对象
    // 往临时目录放东西
    // 不管是出现 return 语句还是有异常抛出，guard 都会被析构，因而该 xxx 目录会被删除

    // 但是如果程序执行到此处，却发生进程的非自然死亡，
    // 在这种情况下，该 guard 对象将不会被析构——因此会留下一个垃圾目录，浪费硬盘资源
}
```

### 类对象的析构（销毁）

类对象分为三种：

- 局部非静态对象
- 局部静态对象
- 全局对象

#### 不同死法对于对象是否能析构的影响

| 类型               | 局部非静态对象 | 局部静态对象 | 全局对象 |
| ------------------ | -------------- | ------------ | -------- |
| 自然死亡           | 能             | 能           | 能       |
| 温和自杀 `exit()`  | 不能           | 能           | 能       |
| 激进自杀 `abort()` | 不能           | 不能         | 不能     |
| 他杀               | 不能           | 不能         | 不能     |

可以看出，应尽量避免他杀以及激进自杀。

对于温和自杀，在调用 `exit()` 之前已经构造但尚未析构的局部非静态对象也将不会被析构，因此也应尽量避免。

#### 析构的顺序

⚠️ 并非让进程自然死亡九绝对安全，这依赖于析构的顺序。

```cpp
class CFoo
{
public:
    CFoo()
    {
        cout << "CFoo" << endl;
    }

    virtual ~CFoo()
    {
        cout << "~CFoo" << endl;
    }
};
```

- 对于用户定义的全局对象，在 C++ 标准中并没有规定它们构造和析构的先后顺序；
- 对于诸如标准输入输出流的 `cout`、`cerr` 等全局对象，在 C++ 03 标准中有提及如何保证它们在最后析构。
- 但由于某些老式编译器并未完全遵照标准实现，导致标准输入输出流的几个全局对象有可能被提前析构。

基于上述原因，假如 `CFoo` 类也定义了一个全局对象 `g_foo`。当 `g_foo` 析构的时候，`cout`
对象有可能已经先死了。
在这种情况下，`CFoo` 析构函数的打印语句由于引用了已死的对象，可能会导致不可预料的后果，比如进程崩溃。

因此，如果在程序中使用全局对象或者静态对象，就要非常小心地编写相关 `class/struct`
的析构函数代码，尽量不要在它们的析构函数中引用其它的全局对象或静态对象。

结论：尽量避免使用全局对象和静态对象，包括标准流类库的那 8 个全局对象（`cout`, `cerr`,
`clog` 等）。

## Win32 线程

### OS API vs CRT API

- OS API: 系统级调用，与编程语言无关
  - `CreateThread`
  - `ExitThread`
- CRT API (Visual C++ RunTime): 除了调用系统级调用，还会做一些语言相关的前后操作
  - `_beginthread` (内部调用 `CreateThread`)
  - `_endthread` (内部调用 `CreateThread`)
  - `_beginthreadex` (内部调用 `ExitThread`)
  - `_endthreadex` (内部调用 `ExitThread`)

### 线程终结的三种方法

#### 自然死亡

通过 `return` 语句结束线程函数的执行。

#### 自杀

通过 CRT API (`_endthread` 或 `_endthreadex`) 将导致析构函数不被调用。

#### 他杀

使用 `TernimateThread` 终止线程。

#### 类对象的析构

全局对象由于是在 `main` 之前就创建，在进程终结时析构，所以和线程关系不大。

| 类型     | 局部非静态对象 | 局部静态对象 |
| -------- | -------------- | ------------ |
| 自然死亡 | 能             | 能           |
| 自杀     | 不能           | 能           |
| 它杀     | 不能           | 能           |

#### 主线程的结束

进程启动时，操作系统会为该进程默认创建第一个线程，可以把 `main` 看作主线程的线程函数。

主线程结束时，即执行 `main` 中的 `return` 时，会导致 `exit` 函数被调用，然后 `exit`
会清除当前进程的各种资源，包括还活着的线程。

因此，主线程务必处理好其他线程之后，自己才能结束退出。

## PISIX 线程 (`pthread`)

- 自然死亡
- 自杀: `pthread_exit`

### pthread 的他杀

在 `pthread` 库中主要使用 `pthread_cancel` 杀线程。
用 `pthread_cancel` 取消线程分两种情况：

- 异步取消 `PTHREAD_CANCEL_ASYNCHRONOUS`: 直接把线程干掉
- 延迟取消 `PTHREAD_CANCEL_DEFERRED`: 被取消的线程会继续运行直到遇见某个“取消点”才终止

`pthread` 库中的 `pthread_kill` 并不是用来“它杀”的。
`pthread_kill` 只不过是给指定的线程发送信号 (`signal`) 而已，发送的可以是有 `kill` 作用的信号，也可以是其他信号。

使用 `pthread_kill` 有一点要小心，如果对应的线程没有处理收到的信号，则该信号可能会影响线程所在的进程，某些情况下可能会导致进程终止（相当于进程自杀）。

### pthread 类对象的析构

|              | 局部非静态对象 | 局部静态对象 |
| ------------ | -------------- | ------------ |
| 自然死亡     | 能             | 能           |
| 自杀         | 不一定能       | 能           |
| 它杀（延迟） | 不一定能       | 能           |
| 它杀（异步） | 不能           | 能           |

- 表中的“不一定能”：不同 OS 平台的行为不一致。
- “异步它杀”是最不安全的，“自然死亡”依然是最安全的。至于“自杀”和“延迟它杀”，则要看具体的环境。

### 主线程之死

在 POSIX 系统里，主线程的自然死亡也会引发 `exit` 被调用，从而导致其它线程被野蛮地干掉。
如果希望主线程退出不引发进程自杀，可以使用 `pthread_exit` 来结束主线程，并让其它线程继续运行。
不过由于线程自杀在某些环境下也不安全，所以建议还是让主线程最后退出比较稳妥。

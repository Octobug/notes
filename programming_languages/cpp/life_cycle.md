# Life Cycle

- [Life Cycle](#life-cycle)
  - [类对象](#类对象)
    - [确保析构执行的重要性](#确保析构执行的重要性)
    - [类对象的析构（销毁）](#类对象的析构销毁)
      - [不同死法对于对象是否能析构的影响](#不同死法对于对象是否能析构的影响)
      - [析构的顺序](#析构的顺序)
  - [Win32 线程](#win32-线程)
    - [OS API vs CRT API](#os-api-vs-crt-api)
    - [线程终结的三种方法](#线程终结的三种方法)
      - [自然死亡](#自然死亡)
      - [自杀](#自杀)
      - [他杀](#他杀)
      - [类对象的析构](#类对象的析构)
      - [主线程的结束](#主线程的结束)

## 类对象

### 确保析构执行的重要性

内存泄漏在进程退出后，内存可以被操作系统回收，但是其他资源却不一定，比程序临时创建的一些文件。

C++ 中常用 Guard 模式来做进程资源的回收：

```cpp
class CTempDirGuard
{
public:
    CTempDirGuard(const string& sFolderName)
    {
        // 创建某临时目录
    }

    virtual ~CTempDirGuard()
    {
        // 把该临时目录整个儿删除
    }
};

void Foo()
{
    CTempDirGuard guard(xxx);  // 声明guard对象
    // 往临时目录放东西
    // 不管是出现 return 语句还是有异常抛出，guard 都会被析构，因而该 xxx 目录会被删除

    // 但是如果程序执行到此处，却发生进程的非自然死亡，
    // 在这种情况下，该 guard 对象将不会被析构——因此会留下一个垃圾目录，浪费硬盘资源
}
```

### 类对象的析构（销毁）

类对象分为三种：

- 局部非静态对象
- 局部静态对象
- 全局对象

#### 不同死法对于对象是否能析构的影响

| 类型               | 局部非静态对象 | 局部静态对象 | 全局对象 |
| ------------------ | -------------- | ------------ | -------- |
| 自然死亡           | 能             | 能           | 能       |
| 温和自杀 `exit()`  | 不能           | 能           | 能       |
| 激进自杀 `abort()` | 不能           | 不能         | 不能     |
| 他杀               | 不能           | 不能         | 不能     |

可以看出，应尽量避免他杀以及激进自杀。

对于温和自杀，在调用 `exit()` 之前已经构造但尚未析构的局部非静态对象也将不会被析构，因此也应尽量避免。

#### 析构的顺序

⚠️ 并非让进程自然死亡九绝对安全，这依赖于析构的顺序。

```cpp
class CFoo
{
public:
    CFoo()
    {
        cout << "CFoo" << endl;
    }

    virtual ~CFoo()
    {
        cout << "~CFoo" << endl;
    }
};
```

- 对于用户定义的全局对象，在 C++ 标准中并没有规定它们构造和析构的先后顺序；
- 对于诸如标准输入输出流的 `cout`、`cerr` 等全局对象，在 C++ 03 标准中有提及如何保证它们在最后析构。
- 但由于某些老式编译器并未完全遵照标准实现，导致标准输入输出流的几个全局对象有可能被提前析构。

基于上述原因，假如 `CFoo` 类也定义了一个全局对象 `g_foo`。当 `g_foo` 析构的时候，`cout`
对象有可能已经先死了。
在这种情况下，`CFoo` 析构函数的打印语句由于引用了已死的对象，可能会导致不可预料的后果，比如进程崩溃。

因此，如果在程序中使用全局对象或者静态对象，就要非常小心地编写相关 `class/struct`
的析构函数代码，尽量不要在它们的析构函数中引用其它的全局对象或静态对象。

结论：尽量避免使用全局对象和静态对象，包括标准流类库的那 8 个全局对象（`cout`, `cerr`,
`clog` 等）。

## Win32 线程

### OS API vs CRT API

- OS API: 系统级调用，与编程语言无关
  - `CreateThread`
  - `ExitThread`
- CRT API (Visual C++ RunTime): 除了调用系统级调用，还会做一些语言相关的前后操作
  - `_beginthread` (内部调用 `CreateThread`)
  - `_endthread` (内部调用 `CreateThread`)
  - `_beginthreadex` (内部调用 `ExitThread`)
  - `_endthreadex` (内部调用 `ExitThread`)

### 线程终结的三种方法

#### 自然死亡

通过 `return` 语句结束线程函数的执行。

#### 自杀

通过 CRT API (`_endthread` 或 `_endthreadex`) 将导致析构函数不被调用。

#### 他杀

使用 `TernimateThread` 终止线程。

#### 类对象的析构

全局对象由于是在 `main` 之前就创建，在进程终结时析构，所以和线程关系不大。

| 类型     | 局部非静态对象 | 局部静态对象 |
| -------- | -------------- | ------------ |
| 自然死亡 | 能             | 能           |
| 自杀     | 不能           | 能           |
| 它杀     | 不能           | 能           |

#### 主线程的结束

进程启动时，操作系统会为该进程默认创建第一个线程，可以把 `main` 看作主线程的线程函数。

主线程结束时，即执行 `main` 中的 `return` 时，会导致 `exit` 函数被调用，然后 `exit`
会清除当前进程的各种资源，包括还活着的线程。

因此，主线程务必处理好其他线程之后，自己才能结束退出。

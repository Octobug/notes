# Life Cycle

- [Life Cycle](#life-cycle)
  - [类对象](#类对象)
    - [确保析构执行的重要性](#确保析构执行的重要性)
    - [类对象的析构（销毁）](#类对象的析构销毁)
      - [不同死法对于对象是否能析构的影响](#不同死法对于对象是否能析构的影响)
      - [析构的顺序](#析构的顺序)

## 类对象

### 确保析构执行的重要性

内存泄漏在进程退出后，内存可以被操作系统回收，但是其他资源却不一定，比程序临时创建的一些文件。

C++ 中常用 Guard 模式来做进程资源的回收：

```cpp
class CTempDirGuard
{
public:
    CTempDirGuard(const string& sFolderName)
    {
        // 创建某临时目录
    }

    virtual ~CTempDirGuard()
    {
        // 把该临时目录整个儿删除
    }
};

void Foo()
{
    CTempDirGuard guard(xxx);  // 声明guard对象
    // 往临时目录放东西
    // 不管是出现 return 语句还是有异常抛出，guard 都会被析构，因而该 xxx 目录会被删除

    // 但是如果程序执行到此处，却发生进程的非自然死亡，
    // 在这种情况下，该 guard 对象将不会被析构——因此会留下一个垃圾目录，浪费硬盘资源
}
```

### 类对象的析构（销毁）

类对象分为三种：

- 局部非静态对象
- 局部静态对象
- 全局对象

#### 不同死法对于对象是否能析构的影响

| 类型               | 局部非静态对象 | 局部静态对象 | 全局对象 |
| ------------------ | -------------- | ------------ | -------- |
| 自然死亡           | 能             | 能           | 能       |
| 温和自杀 `exit()`  | 不能           | 能           | 能       |
| 激进自杀 `abort()` | 不能           | 不能         | 不能     |
| 他杀               | 不能           | 不能         | 不能     |

可以看出，应尽量避免他杀以及激进自杀。

对于温和自杀，在调用 `exit()` 之前已经构造但尚未析构的局部非静态对象也将不会被析构，因此也应尽量避免。

#### 析构的顺序

⚠️ 并非让进程自然死亡九绝对安全，这依赖于析构的顺序。

```cpp
class CFoo
{
public:
    CFoo()
    {
        cout << "CFoo" << endl;
    }

    virtual ~CFoo()
    {
        cout << "~CFoo" << endl;
    }
};
```

- 对于用户定义的全局对象，在 C++ 标准中并没有规定它们构造和析构的先后顺序；
- 对于诸如标准输入输出流的 `cout`、`cerr` 等全局对象，在 C++ 03 标准中有提及如何保证它们在最后析构。
- 但由于某些老式编译器并未完全遵照标准实现，导致标准输入输出流的几个全局对象有可能被提前析构。

基于上述原因，假如 `CFoo` 类也定义了一个全局对象 `g_foo`。当 `g_foo` 析构的时候，`cout`
对象有可能已经先死了。
在这种情况下，`CFoo` 析构函数的打印语句由于引用了已死的对象，可能会导致不可预料的后果，比如进程崩溃。

因此，如果在程序中使用全局对象或者静态对象，就要非常小心地编写相关 `class/struct`
的析构函数代码，尽量不要在它们的析构函数中引用其它的全局对象或静态对象。

结论：尽量避免使用全局对象和静态对象，包括标准流类库的那 8 个全局对象（`cout`, `cerr`,
`clog` 等）。
